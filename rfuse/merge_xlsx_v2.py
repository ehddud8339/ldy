
import sys
from pathlib import Path
import re
from collections import defaultdict, OrderedDict

from openpyxl import load_workbook, Workbook
from openpyxl.styles import Alignment, Font, Border, Side

TARGET_METRICS = ["IOPS", "BW(MB/s)", "lat_avg"]
WORKLOAD_ORDER = ["randread", "randwrite", "read", "write"]

def fs_name_from_path(p: Path) -> str:
    stem = p.stem  # e.g., "ext4_summary"
    m = re.match(r"(.+?)_summary$", stem, re.IGNORECASE)
    return m.group(1) if m else stem

def parse_tables_from_sheet(ws):
    """
    Parse tables from the 'summary' sheet generated by fio_logs_to_format_summary_v2.py
    Returns dict: {(cpus, workload, bs): {metric: [v1,v2,v3,v4]}}, where metrics are TARGET_METRICS.
    """
    max_row = ws.max_row
    cur = 1
    out = defaultdict(dict)

    while cur <= max_row:
        # Look for a header row where B cell has a string like "cpus_workload_bs"
        head = ws.cell(cur, 2).value
        # Next row should be numjobs 1..4 in B..E
        nj_ok = (
            ws.cell(cur+1, 2).value == 1 and
            ws.cell(cur+1, 3).value == 2 and
            ws.cell(cur+1, 4).value == 3 and
            ws.cell(cur+1, 5).value == 4
        ) if cur + 1 <= max_row else False

        if isinstance(head, str) and nj_ok:
            # Expect rows: IOPS, BW(MB/s), lat_avg in column A (cur+2 .. cur+4)
            vals = {}
            for i, metric in enumerate(TARGET_METRICS, start=2):  # rows offset from cur
                label = ws.cell(cur + i, 1).value
                # Accept either exact label or tolerant (case/space)
                if not label or str(label).strip().lower() != metric.lower():
                    # Allow slightly different labeling by comparing in lower
                    pass
                row_vals = [ws.cell(cur + i, c).value for c in range(2, 6)]
                vals[metric] = row_vals
            # Split header into parts
            parts = head.split("_")
            if len(parts) >= 3:
                cpus = parts[0]
                workload = parts[1]
                bs = parts[2]
                out[(cpus, workload, bs)] = vals
            # advance beyond this table (header + nj + 3 metric rows + 3 spacing rows)
            cur += 1 + 1 + len(TARGET_METRICS) + 3
            continue
        else:
            cur += 1

    return out

def sort_cpus_key(cpus: str):
    try:
        return [int(x) for x in cpus.split(",")]
    except Exception:
        return [9999]

def bs_key(bs: str):
    m = re.match(r"(\d+)\s*k$", bs.strip(), re.IGNORECASE)
    return int(m.group(1)) if m else 10**9

def build_output(data_by_fs: dict, fs_order_pref=None):
    """
    data_by_fs: {fs_name: {(cpus, workload, bs): {metric: [v1..v4]}}}
    Returns an ordered list of table keys and a map for quick lookup:
      all_keys: sorted list of (cpus, workload, bs)
      table_map[(cpus,workload,bs,metric)][fs] = [v1..v4]
    """
    # Collect all keys
    key_set = set()
    for fs, d in data_by_fs.items():
        key_set.update(d.keys())
    # Sort keys
    def workload_key(w):
        try:
            return WORKLOAD_ORDER.index(w)
        except ValueError:
            return len(WORKLOAD_ORDER) + (ord(w[0]) if w else 0)

    all_keys = sorted(key_set, key=lambda k: (sort_cpus_key(k[0]), workload_key(k[1]), bs_key(k[2])))

    table_map = defaultdict(lambda: defaultdict(list))
    for fs, d in data_by_fs.items():
        for k in all_keys:
            if k in d:
                for metric in TARGET_METRICS:
                    table_map[(k[0], k[1], k[2], metric)][fs] = d[k].get(metric, [None]*4)
            else:
                for metric in TARGET_METRICS:
                    table_map[(k[0], k[1], k[2], metric)][fs] = [None]*4

    # FS ordering
    if fs_order_pref:
        fs_order = [fs for fs in fs_order_pref if fs in data_by_fs.keys()]
        # add any remaining fs not in preference list
        fs_order += [fs for fs in sorted(data_by_fs.keys()) if fs not in fs_order]
    else:
        fs_order = sorted(data_by_fs.keys())

    return all_keys, table_map, fs_order

def write_output(all_keys, table_map, fs_order, out_path: Path):
    wb = Workbook()
    ws = wb.active
    ws.title = "summary"

    center = Alignment(horizontal="center", vertical="center")
    right = Alignment(horizontal="right", vertical="center")
    bold = Font(bold=True)
    thin = Side(style="thin", color="000000")
    border = Border(left=thin, right=thin, top=thin, bottom=thin)

    current_row = 1
    tables_written = 0

    for (cpus, workload, bs) in all_keys:
        for metric in TARGET_METRICS:
            header = f"{cpus}_{workload}_{bs}_{metric}"
            # Header row (merge B..E)
            ws.merge_cells(start_row=current_row, start_column=2, end_row=current_row, end_column=5)
            h = ws.cell(current_row, 2, header)
            h.font = bold; h.alignment = center
            current_row += 1

            # numjobs header
            for i, nj in enumerate([1,2,3,4], start=2):
                c = ws.cell(current_row, i, nj)
                c.font = bold; c.alignment = center; c.border = border
            current_row += 1

            # FS rows
            for fs in fs_order:
                ws.cell(current_row, 1, fs).font = bold
                ws.cell(current_row, 1).alignment = right
                ws.cell(current_row, 1).border = border

                vals = table_map[(cpus,workload,bs,metric)][fs]
                for i, v in enumerate(vals, start=2):
                    c = ws.cell(current_row, i, v)
                    c.alignment = center; c.border = border
                current_row += 1

            # spacing: 3 rows
            current_row += 3
            tables_written += 1

    # Adjust widths
    ws.column_dimensions["A"].width = 14
    for col in ["B","C","D","E"]:
        ws.column_dimensions[col].width = 12

    out_path.parent.mkdir(parents=True, exist_ok=True)
    wb.save(out_path)
    print(f"[OK] Wrote {tables_written} tables -> {out_path}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 merge_fs_summaries.py <fs1_summary.xlsx> [<fs2_summary.xlsx> ...] [--out OUTPUT.xlsx]")
        print("FS name is derived from filename prefix before '_summary.xlsx' (e.g., 'ext4_summary.xlsx' -> 'ext4').")
        print("Example: python3 merge_fs_summaries.py ext4_summary.xlsx fuse_summary.xlsx rfuse_summary.xlsx --out all_summary.xlsx")
        sys.exit(1)

    args = sys.argv[1:]
    if "--out" in args:
        idx = args.index("--out")
        out_path = Path(args[idx+1])
        files = [Path(p) for p in (args[:idx] + args[idx+2:])]
    else:
        files = [Path(p) for p in args]
        # default output next to first file
        out_path = files[0].parent / "merged_summary.xlsx"

    data_by_fs = {}
    for f in files:
        fs = fs_name_from_path(f)
        wb = load_workbook(f, data_only=True)
        if "summary" not in wb.sheetnames:
            print(f"[WARN] {f} has no 'summary' sheet. Skipped.")
            continue
        ws = wb["summary"]
        data_by_fs[fs] = parse_tables_from_sheet(ws)

    if not data_by_fs:
        print("[ERROR] No data parsed from inputs.")
        sys.exit(2)

    # Prefer FS order ext4, fuse, rfuse
    fs_pref = ["ext4", "fuse", "rfuse"]
    all_keys, table_map, fs_order = build_output(data_by_fs, fs_order_pref=fs_pref)
    write_output(all_keys, table_map, fs_order, out_path)

if __name__ == "__main__":
    main()

